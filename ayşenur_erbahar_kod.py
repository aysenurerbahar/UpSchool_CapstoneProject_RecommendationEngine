# -*- coding: utf-8 -*-
"""Ayşenur Erbahar_Kod.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jc7zORF1fjN42X-Ut7t6rwGJeFUWiHOZ

# Trendyol Recommendation Engine  & Web App
   **Contents**

**1.**   Implementation

**2.**   Loading Data

  * Data Visualization

**3.**   Data Preparation

  * Normalizing Item Values

**4.**   Split Train and Test Set

**5.** Collaborative Filtering Model

  * Cosine Similarity
  * Pearson Similarity

**6.** Content Based Filtering Model

  * Cosine Similarity

**7.** Model Evaluation

**8.** Final Recommendation

# 1. Implementation

Importing Libraries
"""

# Commented out IPython magic to ensure Python compatibility.
# %load_ext autoreload
# %autoreload 2
!pip install turicreate
import pandas as pd
import numpy as np
import time
import turicreate as tc
import random
from sklearn.model_selection import train_test_split

import sys
sys.path.append("..")

#For content based recommendation
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import nltk
import re
# %matplotlib inline
import warnings
warnings.filterwarnings('ignore')

"""#2. Loading data"""

df = pd.read_csv('https://storage.googleapis.com/ty2020/reco.csv.gz')

"""Data setinden RAM alanı sebebiyle sample alıyoruz."""

df = df[df.index < 55000]

"""##Trendyol Data


**Column's Names:**

 0   partition_date: Satın alma tarihi

 1   orderparentid     : Satın alım kodu

 2   user_id           : Satın alan kullanıcı

 3   productcontentid  : Satın alınan ürün kodu

 4   brand_id          : Ürünün marka kodu

 5   category_id       : Ürünün dahil olduğu kategori kodu

 6   category_name     : Ürünün dahil olduğu kategorinin adı

 7   gender            : Ürünün cinsiyeti

 8   price             : Ürünün fiyatı

 9   color_id          : Ürünün renk kodu

 10  business_unit     : Ürünün dahil olduğu genel grubun adı

 11  ImageLink         : Ürün görselinin linki
"""

df.head()

df.info()

"""Veri seti büyük olduğu için SQL kullanabileceğimiz formata getiriyoruz:"""

import sqlite3

conn = sqlite3.connect(":memory:")

df.to_sql("trendyol_data",  conn, if_exists="replace")

"""#2.1. Visualization

Popüler Business Unit kategorilerindeki satışı gözlemlemek amacıyla filtre koyarak bar chart dağılımına hazırlıyoruz:
"""

chart = pd.read_sql(
    """
    select business_unit, count(1) n
    from trendyol_data
    group by business_unit
    order by n desc
    """
    ,conn)

chart= chart[chart['n']>7000]

from matplotlib import pyplot as plt

business_unit = chart['business_unit']
values = chart['n']
   

plt.bar(business_unit, values, color ='maroon',  
        width = 0.8) 
plt.xticks(rotation= 45)
plt.rcParams["figure.figsize"] = [16,9]
  
plt.xlabel("Business Units") 
plt.ylabel("Purchased Products") 
plt.title("Business Unit Bazında Satış Grafiği") 
plt.show()

"""USER BAZLI MODEL İÇİN HAZIRLIK"""

purchase_by_user = pd.read_sql(
    """
    select user_id, productcontentid, count(1) n
    from trendyol_data
    group by user_id, productcontentid
    order by n desc
    """
    ,conn)

purchase_by_user_total = purchase_by_user.groupby(by='user_id').sum().reset_index()
purchase_by_user_total = purchase_by_user.merge(purchase_by_user_total, how='inner', on='user_id')
purchase_by_user_total = purchase_by_user_total.drop(columns=['productcontentid_y'])
purchase_by_user_total.rename(columns= {'productcontentid_x' : 'productcontentid'}, inplace=True)

"""Collabrative Filtering uygulaması az ürün satın alan userlarda daha başarısız çalıştığı gözlemlenmiştir ve bu sebeple, toplam satın alınan ürün(n_y) bazında bir filtreleme işlemi uyguluyoruz:
Daha sonra n_y<5 userlar için Content Based Engine uygulanacaktır.
"""

purchase_by_user = purchase_by_user_total[purchase_by_user_total['n_y']>=5]

"""User bazında satın alınan ürünlerin normalizasyon öncesi istenilen formata getirilmesi:"""

purchase_by_user

"""#3. Data preparation

POPULARİTE BAZLI MODEL İÇİN HAZIRLIK
"""

purchase_by_bu = pd.read_sql(
    """
    select user_id, business_unit, category_name , productcontentid, count(1) n
    from trendyol_data
    group by business_unit
    order by n desc
    """
    ,conn)

purchase_by_bu.head()

"""#3.1. Normalizing item values

User bazında bireysel satın almalar içerisinde ürün dağılımını daha sağlıklı görebilmek için datayı normalize ediyoruz:
"""

purchase_by_user['scaled_purchase_freq'] = purchase_by_user['n_x']/purchase_by_user['n_y']
purchase_by_user

purchase_by_user_norm = purchase_by_user.drop(columns=['n_x','n_y'])

"""#Baseline Model: Popularity

İlk etapta satın alınan ürünlerin business_unit ve category_name dağılımında weight vererek baseline popularity recommendation çalışması yapılmıştır.
"""

pop= pd.read_sql(
    """
    select business_unit, count(1) n
    from trendyol_data
    group by business_unit
    order by n desc
    """,conn
)

pop['weight']= pop[['n']].transform(lambda x: x/x.sum())
pop.head()

pop=pop.drop('n',axis=1)

df_new=df.merge(pop,on=['business_unit']).sort_values('weight',ascending=False)

category=pd.read_sql(
    """
    select category_name, business_unit, count(1) n
    from trendyol_data
    group by  category_name ,business_unit
    order by n desc
    """
    ,conn)

category.sort_values('n',ascending=False)

category['weight']=category[['n']].transform(lambda x: x/x.sum())
category.sort_values('weight',ascending=False)

category.drop('n',axis=1)

df_new=df_new.merge(category,on=['category_name','business_unit']).sort_values('weight_y',ascending=False)

"""Ürünlerin ağırlıklandırılarak değerlendirilmesi:"""

alpha=0.7
df_new['weight'] = alpha* df_new.weight_x + (1-alpha) * df_new.weight_y

df_new=df_new.drop(['weight_x','weight_y'],axis=1)

reco=df_new.sort_values('weight',ascending=False)

reco.to_sql("reco",conn,if_exists='replace')

recom=reco.drop_duplicates(subset='category_name', keep="first")

"""Popularity Recommendation Output:"""

recom.head()

pop_demo = recom.to_csv("recopop.csv")

"""#4. Split train and test set

Öneri modelimizin outputlarını test edebilmek için datayı test ve train olarak ayırıyoruz.
"""

def split_data(data):
    '''
    Splits dataset into training and test set.
    
    Args:
        data (pandas.DataFrame)
        
    Returns
        train_data (tc.SFrame)
        test_data (tc.SFrame)
    '''
    train, test = train_test_split(data, test_size = .2)
    train_data = tc.SFrame(train)
    test_data = tc.SFrame(test)
    return train_data, test_data

train_data, test_data = split_data(purchase_by_user)
train_data_norm, test_data_norm = split_data(purchase_by_user_norm)

user_id = 'user_id'
item_id = 'productcontentid'
users_to_recommend = list(purchase_by_user[user_id].unique())
n_rec = 5 # number of items to recommend
n_display = 30 # to display the first few rows in an output dataset

"""Turicreate Library, model seçimi ve değerlendirmesi yapmak için kullanıyoruz:"""

def model(train_data, name, user_id, item_id, target, users_to_recommend, n_rec, n_display):

    if name == 'cosine':
        model = tc.item_similarity_recommender.create(train_data, 
                                                    user_id=user_id, 
                                                    item_id=item_id, 
                                                    target=target, 
                                                    similarity_type='cosine')
        
    elif name == 'pearson':
        model = tc.item_similarity_recommender.create(train_data, 
                                                    user_id=user_id, 
                                                    item_id=item_id, 
                                                    target=target, 
                                                    similarity_type='pearson')
        
    recom = model.recommend(users=users_to_recommend, k=n_rec)
    recom.print_rows(n_display)
    return model

"""# 5. Collaborative Filtering Model
# 5.1. Cosine Similarity
"""

name = 'cosine' 
target = 'scaled_purchase_freq' 
cos_norm = model(train_data_norm, name, user_id, item_id, target, users_to_recommend, n_rec, n_display)

"""# 5.2. Pearson Similarity"""

name = 'pearson'
target = 'scaled_purchase_freq'
pear_norm = model(train_data_norm, name, user_id, item_id, target, users_to_recommend, n_rec, n_display)

"""# Collaborative Filtering Modeli İçin Method Seçimi"""

models= [cos_norm,pear_norm]
names = ['Cosine Similarity on Scaled Purchase Counts','Pearson Similarity on Scaled Purchase Counts']

eval_norm = tc.recommender.util.compare_models(test_data_norm, models, model_names=names)

"""**FINAL**

Final Model Selection 

Method: Cosine Similarity

Data Set: Scaled Purchase Freq. 

Reason: Final modeline karar verirken RMSE, precision ve recall skorları baz alınarak ve RMSE skorları her iki modelin de birbirine yakın ve başarılı bir sonuç elde etmesine rağmen precision ve recall skorlarının Pearson Similarity modelinde başarılı olması sebebiyle Cosine Similarity modeli seçilmiştir.
"""

final_model = tc.item_similarity_recommender.create(tc.SFrame(purchase_by_user_norm), 
                                            user_id=user_id, 
                                            item_id=item_id, 
                                            target='scaled_purchase_freq', similarity_type='cosine')
recom = final_model.recommend(users=users_to_recommend, k=n_rec)
recom.print_rows(n_display)

"""Final modeli dataframe çevrilmiştir:"""

df_rec = recom.to_dataframe()

"""#6. Content Based Filtering Model

n_y<5 satın alım yapan userlar için Content Based Recommendation yöntemi uygulanmıştır.

Gender column'ında yer alan Nan değerlerin doldurulması:
"""

features = ["gender"]

for feature in features:
  df[feature] = df[feature].fillna('')

"""Content Based Filtering Modelinde uygulanacak Combine_Features'ın category_name ve gender ile oluşturulması:"""

def combine_features(row):
  return row['category_name']+" "+row["gender"]
    
df["combined_features"] = df.apply(combine_features,axis=1)

df.to_sql("trendyol_data_contentbased",  conn, if_exists="replace")

purchase_by_product = pd.read_sql(
    """
    select *, count(1) n
    from trendyol_data_contentbased
    group by productcontentid
    """
    ,conn)
purchase_by_product.drop(columns=['orderparentid','partition_date','brand_id','category_id','color_id','price','business_unit'], inplace=True)
purchase_by_product

"""Cosine Similarity Matrix'i için RAM yeterli gelmemesi sebebiyle userların filtrelenmesi:"""

#purchase_by_product = purchase_by_product[purchase_by_product.index < 20000]

"""Combine Feature sütunundaki noktalama işaretlerinin modelin başarılı çalışabilmesi için kaldırılması:"""

def removePunct (row):
  return re.sub(r'[^\w\s]','',row['combined_features'])

df_purchased = purchase_by_product

df_purchased['combined_features'] = df_purchased.apply(removePunct,axis=1)

"""**Cosine Similarity Modeli**"""

cv = CountVectorizer()
count_matrix = cv.fit_transform(df_purchased["combined_features"])

cosine_sim = cosine_similarity(count_matrix)

def get_title_from_index(index):
    return df_purchased[df_purchased.index == index]["productcontentid"].values[0]

def get_home(index):
    return df_purchased[df_purchased.index == index]["ImageLink"].values[0]

def get_index_from_title(title):
    return df_purchased[df_purchased.productcontentid == title].index.values[0]

product_list = [51973]

"""#8. Final Recommendation

Final outputumuza imagelinkleri web&appte göstermek amacıyla merge ediyoruz:
"""

pd.set_option('display.max_colwidth', -1)

df_img =pd.read_sql(
    """
    select productcontentid, ImageLink, gender, category_name
    from trendyol_data
    group by ImageLink, productcontentid, gender, category_name
    """
    ,conn)

result = df_rec.merge(df_img, on='productcontentid')

result_less = purchase_by_bu.merge(df_img, on='productcontentid')

purchases = purchase_by_user_total.merge(df_img, on='productcontentid')

result_less.rename(columns={'category_name_x':'category_name'}, inplace=True)

def purchased(user_id):
  df_purchased = purchases.loc[purchases['user_id']==user_id,['productcontentid', 'category_name' ,'ImageLink']]
  return df_purchased

"""df : tüm userların toplam satın alma dataframe'i (purchase_by_user_total)

df2 : for collabrative filtering

content_based_res : for content based filtering

Aşağıdaki satırda;
Recommendation yapılacak userların satın alma sayılarını inceleyip ona göre recommendation engine için target data seçimi yapılmaktadır. Buna göre: n<5 için content based filtering uygulanmaktadır. Geri kalan kullanıcılar için(n>5) Collaborative Filtering ile recommendation yapmaktadır. 
Bunun sebebi ise user bazlı yaklaşımlarda userların davranışlarını sadece satın alma datasından öneri sonucu çok başarılı olmadığı için Content Based ile daha önce satın alınan içeriğe göre recommendation hedeflenmektedir.
"""

def recommended(user_id):
  df = purchase_by_user_total
  df2 = result
  content_based_res = pd.DataFrame(columns=['productcontentid'])
  if df.loc[df['user_id']==user_id,['n_y']].iloc[0,0] < 6:
    product_list = list(purchased(user_id).productcontentid)
    for product in product_list:
      product_index = get_index_from_title(product)
      similar_products =  list(enumerate(cosine_sim[product_index]))
      sorted_similar_products = sorted(similar_products,key=lambda x:x[1],reverse=True)
      i=0
      for element in sorted_similar_products:
        if product == get_title_from_index(element[0]):
          continue
        else:
          new_row = {'productcontentid' : get_title_from_index(element[0]) }
          content_based_res = content_based_res.append(new_row, ignore_index=True)
          i=i+1
          if i>4:
              break
      content_based_res = content_based_res.merge(df_img, on='productcontentid')
    return content_based_res
  else:
    df_reco = df2.loc[df2['user_id']==user_id,['productcontentid', 'category_name' ,'ImageLink']]
    return df_reco

rand_user = random.choice(list(purchase_by_product.user_id))
print("user_id:", rand_user)
purchased(rand_user)

print("user_id:", rand_user)
recommended(rand_user)

df_1 = recommended(rand_user)

import csv

collaborative_demo = df_1.to_csv("collab.csv")